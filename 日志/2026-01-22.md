---
area: "[[日志]]"
tags:
  - day
createTime: "2026-01-22 12:40:18"
doneTime: "2026-01-22 12:40:18"
---
## 执行清单
- [ ] 复盘总结
- [ ] 练琴
- [ ] 100俯卧撑 

## 日志

## 今日总结

## 1. 通用命名规则

### 总述

函数、变量、文件、类型等**所有命名实体**需具备**强描述性 + 完整语义**，使用全行业公认完整单词 / 缩写，**禁止任何形式的极简缩写 / 项目私有缩写 / 随意删字母缩写**；嵌入式硬件相关命名**必须强制添加完整硬件标识**，无模糊、无省略。

### 强制说明

1. **无极简特例**：取消`i/j/k`循环索引、`T/U`模板参数、`tmp/val`通用临时变量等所有极简命名特例，**所有标识均需语义化 + 专属化**。
2. **缩写规则**：仅允许**行业通用、全行业公认**的完整缩写（如`buf`=buffer、`freq`=frequency、`len`=length、`idx`=index），缩写需在项目内统一并纳入文档管理，禁止自定义。
3. **硬件标识**：嵌入式硬件相关命名，必须包含**项目名 + 芯片型号 + 外设缩写 + 外设编号 + 引脚 / 通道编号**，形成唯一标识，避免跨项目 / 跨硬件冲突。
4. **长度控制**：以语义完整为前提，嵌入式场景命名字符数控制在**5-30 个**，兼顾可读性与调试符号表内存占用。
5. **术语同步**：嵌入式命名的功能描述需与**芯片官方数据手册 / 参考手册**术语严格一致，禁止自定义术语。

### 正例

c++

```
int system_error_count;                // 无缩写，语义完整
uint8_t temp_mon_stm32f103_uart1_receive_data_buffer[128]; // 硬件标识完整
float stm32f103_adc3_channel8_analog_voltage_value;        // 功能+硬件双完整
```

### 反例

c++

```
int nerr;                  // 极简缩写，无任何语义
int uart1_rx_buf[128];     // 缺失项目+芯片标识，模糊命名
int i;                     // 无意义单字母，无极简特例
float adc_val;             // 极简缩写，硬件标识完全缺失
```

## 2. 文件命名规则

### 总述

文件名**全部小写**，单词之间用下划线`_`分隔（强制）；C++ 源文件以`.cc`结尾，头文件以`.h`结尾，纯文本插入文件以`.inc`结尾；**禁止与系统头文件重名**（如`db.h`/`stdio.h`），禁止极简文件名（如`log.h`/`drv.h`），必须体现**项目 + 芯片 + 模块 + 功能**。

### 强制说明

1. **命名格式**：`项目名_芯片型号_模块/外设_编号_具体功能_文件类型.(h/cc)`，嵌入式驱动 / 配置 / 应用文件需按功能细分文件类型（`driver`/`config`/`module`/`app`）。
2. **类文件配对**：定义类 / 结构体的文件需成对出现，文件名与类型名严格对应（如类型`TempMonStm32f103Uart1SerialDriver`对应`temp_mon_stm32f103_uart1_serial_driver.h/.cc`）。
3. **头文件保护宏**：强制添加防重复包含宏，命名规则为`_项目名_芯片型号_模块_文件名_H_`（全大写 + 下划线），与文件名严格对应，禁止极简宏名。
4. **文件细分**：禁止单一文件包含多功能，按 “硬件外设 / 业务功能” 拆分，如`uart1_serial_send.h`与`uart1_serial_receive.h`分开定义。

### 正例

c++

```
// temp_mon_stm32f103_uart1_serial_driver.h 保护宏（完整标识）
#ifndef _TEMP_MON_STM32F103_UART1_SERIAL_DRIVER_H_
#define _TEMP_MON_STM32F103_UART1_SERIAL_DRIVER_H_
// 内容省略
#endif // _TEMP_MON_STM32F103_UART1_SERIAL_DRIVER_H_

// 嵌入式文件命名示例（全域无极简）
temp_mon_stm32f103_uart1_serial_driver.h、temp_mon_stm32f103_i2c2_sensor_collect_module.cc
temp_mon_stm32f103_system_clock_config.h、temp_mon_stm32f103_adc3_channel8_sample_driver.cc
utils_crc8_calculate_module.h、app_temperature_data_upload_module.cc
```

### 反例

c++

```
uart1_drv.h、log.h、drv.h // 极简缩写，无项目+芯片标识
Uart1SerialDriver.h      // 大小写混合，违反命名规则
_UART1_DRIVER_H_         // 保护宏极简，无任何专属标识
temp_mon_stm32f103_uart1.cc // 无功能标识，语义模糊
```

## 3. 类型命名规则

### 总述

所有类型名称采用**大驼峰（PascalCase）**，每个单词首字母大写，无下划线；类型包含类、结构体、`typedef`、`using`别名、枚举、类型模板参数；**禁止极简类型名**，所有类型名需**完整专属化 + 语义后缀强制**，模板参数无极简特例。

### 强制说明

1. **语义后缀强制**：类型名必须添加专属语义后缀，明确类型用途，无例外（如`Driver`/`Config`/`Properties`/`Enum`/`Map`/`Buffer`/`State`/`Handler`）。
2. **嵌入式特化**：硬件相关类型名格式为`项目名芯片型号外设缩写编号功能+语义后缀`，完整体现硬件关联，禁止省略任何标识。
3. **模板参数命名**：取消`T/U/V`等极简模板参数特例，按**类型用途大驼峰命名**（如`DataType`/`ContainerType`/`HardwareConfigType`）。
4. **类型别名**：`typedef`/`using`别名遵循相同规则，禁止极简别名（如`uint`/`u8`），需体现**用途 + 类型 + 单位**（如`SystemTickMillisecondCount`/`Uart1SerialReceiveBuffer`）。

### 正例

c++

```
// 类/结构体（硬件全标识+语义后缀）
class TempMonStm32f103Uart1SerialDriver { ... };
struct TempMonStm32f103Gpioa5LedProperties { ... };
class TempMonStm32f103TemperatureCollectModule { ... };

// typedef/using别名（完整语义，无极简）
typedef uint32_t TempMonStm32f103SystemTickMillisecondCount;
using TempMonStm32f103Uart1ReceiveBuffer = uint8_t[128];
using TempMonStm32f103SensorDataKeyValueMap = hash_map<uint16_t, float>;

// 枚举（硬件全标识+Enum后缀）
enum TempMonStm32f103Adc3Channel8SampleModeEnum { ... };

// 模板参数（语义化大驼峰，无极简）
template <typename DataType, typename ContainerType>
class TempMonCircularDataBuffer { ... };
```

### 反例

c++

```
class Uart1Driver { ... };    // 无项目+芯片标识，极简
struct Gpioa5LedProps { ... }; // 后缀极简缩写，语义模糊
typedef uint32_t SysTick;     // 语义不完整，无项目+单位标识
template <typename T, typename U> // 极简模板参数，无任何意义
class CircularBuffer { ... };
enum Adc3SampleMode { ... };  // 无项目+芯片+Enum后缀，标识缺失
```

## 4. 变量命名规则

### 总述

变量（含函数参数）、数据成员名一律**小写 + 下划线**分隔；**类的非静态 / 静态数据成员以下划线`_`结尾**，结构体的数据成员**不加下划线结尾**；**禁止任何极简变量名**，所有变量需**完整语义化 + 硬件全标识**（嵌入式），参数与变量语义严格匹配。

### 强制说明

#### 4.1 普通变量 / 函数参数

命名格式：`项目名_芯片型号_外设/模块_编号_功能_数据类型_状态/单位`，体现**用途 + 类型 + 范围 + 硬件关联**，嵌入式硬件变量禁止省略任何标识，函数参数与变量语义完全一致，无极简参数名。

#### 4.2 类数据成员

在普通变量规则基础上**加下划线`_`结尾**，可直接接收同名语义化参数，避免命名冲突；成员变量需体现**类归属 + 功能 + 类型**，无极简、无模糊。

#### 4.3 结构体数据成员

与普通变量规则一致，**不加下划线结尾**；硬件相关结构体成员需与芯片手册寄存器 / 外设功能严格对应，语义与手册同步，禁止极简描述。

#### 4.4 嵌入式硬件变量特化

寄存器操作、外设数据、总线缓存、引脚状态等硬件变量，必须包含**项目 + 芯片 + 外设 + 编号 + 引脚 / 通道 + 功能 + 单位**，与硬件实际功能一一对应，无任何缩写与省略。

### 正例

c++

```
// 普通变量/函数参数（硬件全标识，语义完整）
uint32_t temp_mon_stm32f103_system_clock_frequency_hz;
uint8_t temp_mon_stm32f103_uart1_receive_data_buffer[128];
uint16_t temp_mon_stm32f103_adc3_channel8_analog_sample_value;
// 函数参数与变量语义完全匹配
void temp_mon_stm32f103_uart1_send_serial_data(
    uint8_t* temp_mon_stm32f103_uart1_send_data_buffer,
    uint16_t temp_mon_stm32f103_uart1_send_data_length
) { ... }

// 类数据成员（下划线结尾+完整语义）
class TempMonStm32f103Uart1SerialConfig {
private:
    uint32_t serial_baud_rate_hz_;
    uint8_t serial_data_bit_count_;
    uint8_t serial_stop_bit_count_;
    static uint8_t serial_init_complete_flag_;
public:
    // 同名语义化参数，无冲突
    TempMonStm32f103Uart1SerialConfig(uint32_t serial_baud_rate_hz) 
        : serial_baud_rate_hz_(serial_baud_rate_hz) { ... }
};

// 结构体数据成员（无下划线+硬件语义完整）
struct TempMonStm32f103GpioConfig {
    uint8_t gpio_port_letter;
    uint8_t gpio_pin_number;
    uint8_t gpio_working_mode;
    uint8_t gpio_pull_up_down_type;
    static uint32_t gpio_port_base_address;
};
```

### 反例

c++

```
uint32_t sys_clk; // 极简缩写，无项目+芯片+单位标识
uint8_t uart1_rx_buf[128]; // 缺失项目+芯片，功能缩写极简
class Uart1Config {
private:
    uint32_t baud_rate_; // 无serial标识，语义不完整
};
struct GpioConfig {
    uint8_t pin; // 极简，无端口/编号/项目标识
};
// 函数参数极简，与变量语义不匹配
void uart1_send(uint8_t* buf, uint16_t len) { ... }
```

## 5. 常量命名规则

### 总述

声明为`constexpr`/`const`的变量、静态存储类型变量（全局 / 静态）、程序运行期不变量，命名以 **`k`开头 + 大驼峰 **，无下划线；**禁止任何极简常量名**，所有常量需添加**单位 + 范围 + 硬件全标识**（嵌入式），非静态存储常量遵循同一规则，无例外。

### 强制说明

1. **`k`前缀原则**：`k`为小写，后续单词首字母大写，体现常量属性；常量名格式为`k+项目名芯片型号外设编号功能值含义+单位`，语义完整，无省略。
2. **嵌入式特化**：硬件相关常量必须与芯片手册参数一致，包含**项目 + 芯片 + 外设 + 编号 + 功能 + 值含义 + 单位**，禁止省略芯片 / 编号 / 单位（如波特率需加`Bps`、频率需加`Hz`）。
3. **系统级常量特例**：与 C/C++ 标准库常量风格一致的（如`INT_MAX`），需在标准库名基础上补充**项目 + 完整语义**（如`kTempMonStandardLibraryUint32MaxValue`），禁止直接使用极简标准库名。
4. **值含义明确**：常量名需直接体现值的实际含义，禁止仅用`Max`/`Min`/`Default`等模糊描述，需搭配具体对象（如`kTempMonStm32f103Uart1SerialMaxReceiveBufferLengthByte`）。

### 正例

c++

```
// 通用常量（k开头+完整语义+单位）
const int kTempMonCalendarDaysInAWeekValue = 7;
constexpr float kTempMonMathematicsPiPreciseValue = 3.1415926535;
static const uint32_t kTempMonSystemMaxDataBufferLengthByte = 256;

// 嵌入式硬件常量（硬件全标识+语义+单位）
const uint32_t kTempMonStm32f103Uart1SerialBaudRateValueBps = 115200;
constexpr uint8_t kTempMonStm32f103I2c2SensorDeviceAddressHex = 0x48;
const uint16_t kTempMonStm32f103Adc3Channel8SampleMaxValue = 4095;
static const uint32_t kTempMonStm32f103SystemClockFrequencyValueHz = 72000000;

// 系统级常量（补充项目+完整语义）
const uint32_t kTempMonStandardLibraryUint32MaxValue = 0xFFFFFFFF;
```

### 反例

c++

```
const int kDaysInAWeek = 7; // 无项目+Value后缀，语义不完整
constexpr uint32_t kUart1BaudRate = 115200; // 无项目+芯片+单位标识
static const uint32_t kMaxBufLen = 256; // 极简缩写，无项目+单位
const uint32_t ULONG_MAX = 0xFFFFFFFF; // 极简，无k前缀+项目语义
```

## 6. 函数命名规则

### 总述

所有函数（全局 / 类 / 命名空间 / 硬件驱动）采用**大驼峰（PascalCase）**，无下划线；**禁止任何极简函数名**，函数名需完整体现**动作 + 主体 + 功能 + 具体操作**；取值 / 设值函数与对应变量名严格匹配，无极简前缀 / 名。

### 强制说明

1. **通用函数命名**：格式为`动作+功能模块+具体操作+结果/参数类型`，大驼峰无下划线，语义完整，禁止极简动作词（如`Add`而非`A`，`Delete`而非`Del`）。
2. **取值 / 设值函数**：与对应变量名语义完全一致，取值函数直接使用变量语义名，设值函数加`Set`前缀（禁止`Get`/`SetVal`等极简形式），如变量`serial_baud_rate_hz_`对应`SerialBaudRateHz()`/`SetSerialBaudRateHz()`。
3. **嵌入式特化命名**
    
    - 驱动函数：`项目名芯片型号外设编号+动作+功能+具体操作`（如`TempMonStm32f103Uart1SendSerialData`）。
    - 中断处理函数：`Irq+项目名芯片型号外设编号+中断类型+Handler`（如`IrqTempMonStm32f103Uart1ReceiveInterruptHandler`）。
    - 硬件操作函数：`项目名芯片型号硬件编号+动作+功能+状态/值`（如`TempMonStm32f103Gpioa5SetPinLevelState`）。
    
4. **首字母缩写处理**：行业通用缩写视作一个单词，仅首字母大写（如`TempMonStm32f103Uart1StartRpcComm`而非`TempMonStm32f103Uart1StartRPCComm`）。

### 正例

c++

```
// 通用函数（完整语义，无极简）
TempMonAddDataTableEntryRecord();
TempMonDeleteNetworkUrlAddress();
TempMonOpenFileSystemFileWithCheck();

// 取值/设值函数（与变量严格匹配，语义完整）
uint32_t SerialBaudRateHz() const { return serial_baud_rate_hz_; }
void SetSerialBaudRateHz(uint32_t serial_baud_rate_hz) { serial_baud_rate_hz_ = serial_baud_rate_hz; }

// 嵌入式驱动/硬件函数（硬件全标识，动作完整）
void TempMonStm32f103Uart1SendSerialData(uint8_t* send_data_buffer, uint16_t send_data_length);
uint8_t TempMonStm32f103I2c2ReadSensorRegisterData(uint8_t device_address, uint8_t register_address);
void TempMonStm32f103Gpioa5SetPinLevelState(uint8_t pin_level_state);
void IrqTempMonStm32f103Uart1ReceiveInterruptHandler(void);
uint16_t TempMonStm32f103Adc3Channel8CollectAnalogSampleValue(void);
```

### 反例

c++

```
void SendData(); // 无硬件/项目标识，动作+功能极简
void Uart1Init(); // 无项目+芯片标识，动作极简
void SetBaudRate(uint32_t rate); // 与变量名不匹配+参数极简
void IrqUart1RxHandler(void); // 中断类型+Handler极简，无项目+芯片标识
uint16_t Adc3Sample(void); // 无项目+芯片+通道，功能描述模糊
```

## 7. 命名空间命名规则

### 总述

命名空间以**小写 + 下划线**命名，**禁止极简命名空间名**；按 “项目 + 芯片 + 模块 + 功能” 层级强制划分，每层命名均为完整语义，无模糊、无极简，与项目物理目录结构严格一致。

### 强制说明

1. **层级格式**：顶级命名空间为**项目完整名**，二级为**芯片型号完整缩写**，三级为**外设 / 模块完整名**，四级为**具体功能**，如`temp_monitor_project::stm32f103_chip::uart1_serial_module::transmit_function`。
2. **internal 子命名空间**：项目内部私有代码命名格式为`芯片_模块_internal`，禁止单独使用`internal`极简名；若存在冲突，添加具体功能后缀（如`stm32f103_uart1_serial_transmit_internal`）。
3. **冲突规避**：禁止使用标准库 / 第三方库极简命名（如`std`/`boost`/`util`/`drv`），所有命名空间名需添加**项目 + 芯片标识**，避免跨项目 / 跨库冲突。
4. **目录匹配**：命名空间层级与项目物理目录结构一一对应，便于代码查找与管理，如命名空间`temp_mon::stm32f103::uart1`对应目录`temp_mon/stm32f103/uart1/`。

### 正例

c++

```
// 项目+芯片+模块+功能 层级（无极简，与目录匹配）
namespace temp_monitor_project {
    namespace stm32f103_chip {
        namespace uart1_serial_module {
            namespace transmit_function {
                void TempMonStm32f103Uart1SendSerialData(uint8_t* data_buffer, uint16_t data_length);
            }
            namespace receive_function {
                void TempMonStm32f103Uart1ReceiveSerialData(uint8_t* data_buffer, uint16_t data_length);
            }
        }
        namespace i2c2_sensor_module {
            void TempMonStm32f103I2c2ReadSensorCollectData(uint8_t* data_buffer, uint16_t data_length);
        }
        // 内部私有命名空间（完整标识，无极简internal）
        namespace stm32f103_system_clock_internal {
            void TempMonStm32f103InitSystemClockFrequency(uint32_t clock_frequency_hz);
        }
    }
}

// 调用示例（语义完整，标识明确）
temp_monitor_project::stm32f103_chip::uart1_serial_module::transmit_function::TempMonStm32f103Uart1SendSerialData(buf, len);
```

### 反例

c++

```
namespace temp_mon { // 项目名极简缩写，无完整标识
namespace stm32f103 {    // 无chip后缀，层级语义不完整
namespace uart1 {        // 无serial_module标识，极简
namespace internal {     // 单独极简internal，无模块+功能标识
}
}
}
namespace util { // 通用极简名，易与第三方库冲突
}
```

## 8. 枚举命名规则

### 总述

枚举**类型名**遵循[类型命名规则](#3-%E7%B1%BB%E5%9E%8B%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99)（项目 + 芯片 + 外设 + 功能 +`Enum`后缀，大驼峰）；枚举**值**遵循[常量命名规则](#5-%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99)（`k`开头 + 大驼峰 + 完整语义）；**禁止所有极简枚举名**，枚举值需体现**枚举类型归属 + 具体含义 + 状态 / 值属性**，无通用极简值（如`kOk`/`kError`）。

### 强制说明

1. **枚举类型名强制**：格式为`项目名芯片型号外设编号功能+ErrorType/Mode/State+Enum`，完整体现枚举适用范围与类型，禁止模糊 / 极简，`Enum`后缀为强制项。
2. **枚举值命名规则**：`k+枚举类型核心语义+具体状态+值属性`，与枚举类型强关联，**禁止跨类型通用名**（如`kUart1SerialErrorNoneValue`而非`kOk`），所有值需专属化。
3. **嵌入式特化**：硬件相关枚举值需与芯片手册寄存器状态 / 外设功能严格对应，体现**硬件动作 / 状态 / 错误类型**，无极简状态描述（如`kGpioPinModeInputFloating`而非`kInput`）。
4. **值属性明确**：枚举值需添加值属性后缀（如`Value`/`State`/`Mode`），明确枚举值的实际用途，禁止仅用状态描述。

### 正例

c++

```
// 嵌入式硬件枚举（完整类型名+专属枚举值，无极简）
enum TempMonStm32f103Uart1SerialErrorTypeEnum {
    kTempMonStm32f103Uart1SerialErrorNoneValue = 0,
    kTempMonStm32f103Uart1SerialErrorMemoryAllocateFail,
    kTempMonStm32f103Uart1SerialErrorReceiveDataTimeout,
    kTempMonStm32f103Uart1SerialErrorParityCheckFail,
    kTempMonStm32f103Uart1SerialErrorStopBitMismatch,
};
enum TempMonStm32f103GpioPinWorkingModeEnum {
    kTempMonStm32f103GpioPinModeInputFloating,
    kTempMonStm32f103GpioPinModeOutputPushPull,
    kTempMonStm32f103GpioPinModeInputPullUp,
    kTempMonStm32f103GpioPinModeInputPullDown,
    kTempMonStm32f103GpioPinModeAlternateFunctionPushPull,
};
```

### 反例

c++

```
enum Uart1Error { // 无项目+芯片+ErrorType+Enum后缀，类型名极简
    kOk = 0,      // 通用极简值，无项目+硬件专属语义
    kMemFail,     // 缩写极简，语义模糊
    kRxTimeout,   // 无serial标识，语义不完整
    kParityError, // 无项目+芯片前缀，归属不明确
};
enum GpioMode { // 无项目+芯片+Pin+Enum后缀，极简
    Input,       // 无Mode/State标识，语义不完整
    Output,
    PullUp,
};
```

## 9. 宏命名规则

### 总述

**尽可能避免使用宏**，仅在**寄存器位操作 / 条件编译 / 动态参数计算**等常量无法实现的场景使用；宏名**全大写 + 下划线**分隔，**禁止任何极简宏名**，所有宏需体现**项目 + 芯片 + 功能 + 操作**，参数为完整语义化命名，强制加括号避免运算优先级问题。

### 强制说明

1. **宏与常量区分**：优先使用`constexpr`/`const`替代宏定义常量，宏仅用于**硬件寄存器位操作、条件编译开关、带参数的动态计算**，禁止用宏定义固定值。
2. **宏命名格式**
    
    - 硬件寄存器 / 引脚宏：`项目名_芯片型号_外设编号_硬件类型_功能_地址/引脚/位标识`
    - 宏函数：`项目名_功能模块_具体操作_计算类型`，参数为完整语义名，禁止极简参数（如`x`/`a`/`b`）
    - 条件编译宏：`CFG_项目名_芯片型号_模块_功能_使能/配置_状态`，`CFG_`前缀为强制项，后续语义完整
    
3. **嵌入式硬件宏特化**：寄存器位操作宏需与芯片手册寄存器位定义一致，体现**寄存器名 + 位功能 + 操作类型**，禁止极简位标识（如`UART1_SERIAL_RECEIVE_DATA_NOT_EMPTY_BIT`而非`RXNE`）。
4. **宏参数规则**：宏函数的参数需与函数参数命名规则一致，为**完整语义化命名**，强制为参数添加括号，避免运算优先级问题。

### 正例

c++

```
// 通用宏函数（完整名+语义化参数，强制括号）
#define TEMP_MON_CALCULATE_ROUND_FLOAT_VALUE(float_input_value) ((float_input_value) + 0.5f)
#define TEMP_MON_GET_MINIMUM_COMPARE_VALUE(first_compare_value, second_compare_value) \
    ((first_compare_value) < (second_compare_value) ? (first_compare_value) : (second_compare_value))

// 嵌入式硬件寄存器/引脚宏（硬件全标识，无极简）
#define TEMP_MON_STM32F103_UART1_SERIAL_BASE_ADDRESS 0x40013800
#define TEMP_MON_STM32F103_GPIOA_5_PIN_BIT_MASK (1 << 5)
#define TEMP_MON_STM32F103_UART1_SERIAL_RECEIVE_DATA_NOT_EMPTY_BIT (1 << 5)

// 嵌入式条件编译配置宏（CFG_+完整语义）
#define CFG_TEMP_MON_STM32F103_SYSTEM_CLOCK_FREQUENCY_HZ 72000000
#define CFG_TEMP_MON_STM32F103_UART1_SERIAL_FUNCTION_ENABLE 1
#define CFG_TEMP_MON_STM32F103_ADC3_CHANNEL8_SAMPLE_FREQUENCY_HZ 1000

// 嵌入式硬件操作宏（完整功能+语义化参数）
#define TEMP_MON_STM32F103_UART1_SET_SERIAL_BAUD_RATE(baud_rate_hz) \
    (USART1->BRR = (kTempMonStm32f103SystemClockFrequencyValueHz / (baud_rate_hz)))
#define TEMP_MON_STM32F103_GPIOA_5_SET_PIN_HIGH_LEVEL() \
    (GPIOA->BSRR = TEMP_MON_STM32F103_GPIOA_5_PIN_BIT_MASK)
```

### 反例

c++

```
#define ROUND(x) (x + 0.5) // 极简名+极简参数，无项目标识，无括号
#define UART1_BASE 0x40013800 // 无项目+芯片+serial标识，极简
#define CFG_UART1_ENABLE 1 // 无项目+芯片+功能标识，极简
#define GPIOA5_SET_HIGH() (GPIOA->BSRR = GPIOA5_PIN) // 无项目+芯片标识
#define MIN(a, b) ((a) < (b) ? (a) : (b)) // 极简参数，无语义，无项目标识
#define UART1_RXNE_BIT (1 << 5) // 极简位标识，无serial+功能描述
```

## 10. 临时变量专属命名规则（全域无极简）

### 总述

临时变量指**函数内局部使用、生命周期仅在代码块内**的变量（循环索引 / 类型转换 / 指令加载 / 寄存器操作 / 计算缓存 / 中断临时存储）；**取消所有极简临时变量特例**，禁止`i/j/k`/ 纯`tmp`/ 单字母，所有临时变量遵循 **`tmp_`前缀 + 完整语义化命名 **，体现**项目 + 芯片 + 用途 + 类型 + 操作**，中断内临时变量无极简许可，需与通用临时变量保持一致。

### 强制说明

所有临时变量统一以 **`tmp_`为强制前缀 **，后续跟`小写+下划线`的完整语义描述，嵌入式硬件相关临时变量需添加**项目 + 芯片 + 外设 + 编号**全标识，明确**所属模块 + 具体操作 + 数据类型 + 用途**，禁止任何形式的极简与模糊。

#### 10.1 循环索引临时变量

**命名规则**：`tmp_项目名_芯片型号_循环所属模块_循环对象_索引类型_idx`，取消`i/j/k`极简特例，单层 / 多层循环均需专属语义化索引名，多层循环通过**循环对象**区分，禁止通用索引名。

#### 10.2 类型转换临时变量

**命名规则**：`tmp_项目名_芯片型号_所属功能_原数据类型_full_转目标数据类型_full_转换结果`，类型名使用完整形式（`uint8_t`/`uint32_t`/`float`/`int32_t`），禁止缩写（`u8`/`u32`），明确转换所属功能与完整类型关系。

#### 10.3 指令加载临时变量

**命名规则**：`tmp_项目名_芯片型号_外设_编号_加载数据类型_加载用途_load_data`，适用于寄存器值、Flash/ROM 数据、DMA 缓冲区、外设数据的加载操作，完整体现硬件标识与加载用途。

#### 10.4 寄存器位操作临时变量

**命名规则**：`tmp_项目名_芯片型号_外设_编号_寄存器名_位功能_位操作类型_bit_data`，适用于寄存器位的读取 / 设置 / 判断 / 修改，体现**硬件 + 寄存器 + 位功能 + 操作类型**，无极简标识。

#### 10.5 通用计算 / 缓存临时变量

**命名规则**：`tmp_项目名_芯片型号_所属功能_计算/缓存对象_数据类型_临时用途`，适用于临时校验和、临时计数值、临时缓冲区、临时状态存储，禁止单独使用`tmp`，语义完整无模糊。

#### 10.6 中断服务函数临时变量

**取消 “极简优先” 特例**，命名规则与通用临时变量一致：`tmp_项目名_芯片型号_外设_编号_中断类型_临时用途_data`，保证中断代码可读性，无任何极简形式，禁止单字母 / 纯`tmp`。

### 正例

c++

```
// 10.1 循环索引临时变量（无i/j/k，多层循环区分对象）
// 单层循环：UART1接收数据缓冲区字节遍历
for (uint16_t tmp_temp_mon_stm32f103_uart1_serial_receive_byte_data_idx = 0; 
     tmp_temp_mon_stm32f103_uart1_serial_receive_byte_data_idx < temp_mon_stm32f103_uart1_receive_data_length; 
     tmp_temp_mon_stm32f103_uart1_serial_receive_byte_data_idx++) { ... }

// 双层循环：I2C2传感器数据帧+字节遍历
for (uint8_t tmp_temp_mon_stm32f103_i2c2_sensor_data_frame_idx = 0; 
     tmp_temp_mon_stm32f103_i2c2_sensor_data_frame_idx < 4; 
     tmp_temp_mon_stm32f103_i2c2_sensor_data_frame_idx++) {
    for (uint8_t tmp_temp_mon_stm32f103_i2c2_sensor_frame_byte_data_idx = 0; 
         tmp_temp_mon_stm32f103_i2c2_sensor_frame_byte_data_idx < 8; 
         tmp_temp_mon_stm32f103_i2c2_sensor_frame_byte_data_idx++) { ... }
}

// 10.2 类型转换临时变量（完整类型，无缩写，硬件全标识）
float tmp_temp_mon_stm32f103_adc3_channel8_analog_voltage_float_value = 3.3f;
uint32_t tmp_temp_mon_stm32f103_adc3_channel8_float_to_uint32_t_conversion_result = (uint32_t)tmp_temp_mon_stm32f103_adc3_channel8_analog_voltage_float_value;

// 10.3 指令加载临时变量（硬件全标识，加载用途明确）
uint32_t tmp_temp_mon_stm32f103_gpioa_mode_register_uint32_t_load_data = *GPIOA_MODER;
uint8_t tmp_temp_mon_stm32f103_uart1_serial_data_uint8_t_peripheral_load_data = USART1->DR;

// 10.4 寄存器位操作临时变量（硬件+寄存器+位功能+操作）
uint32_t tmp_temp_mon_stm32f103_gpioa_5_pin_mode_register_read_operation_bit_data = (GPIOA->MODER & GPIO_MODER_MODE5) >> 10;
uint32_t tmp_temp_mon_stm32f103_uart1_serial_irq_enable_register_set_operation_bit_data = USART1->CR1 | USART1_CR1_RXNEIE;

// 10.5 通用计算/缓存临时变量（完整语义，无极简）
uint8_t tmp_temp_mon_stm32f103_uart1_serial_data_uint8_t_check_sum_calculate = 0;
uint32_t tmp_temp_mon_stm32f103_system_tick_uint32_t_millisecond_count = HAL_GetTick();
uint8_t tmp_temp_mon_stm32f103_sensor_data_uint8_t_parse_cache_buffer[16];

// 10.6 中断服务函数临时变量（无极简，完整语义）
void IrqTempMonStm32f103Uart1ReceiveInterruptHandler(void) {
    uint8_t tmp_temp_mon_stm32f103_uart1_serial_receive_uint8_t_interrupt_data = USART1->DR;
    uint32_t tmp_temp_mon_stm32f103_uart1_serial_status_register_uint32_t_interrupt_data = USART1->SR;
    if (tmp_temp_mon_stm32f103_uart1_serial_status_register_uint32_t_interrupt_data & TEMP_MON_STM32F103_UART1_SERIAL_RECEIVE_DATA_NOT_EMPTY_BIT) {
        temp_mon_stm32f103_uart1_receive_data_buffer_[temp_mon_stm32f103_uart1_receive_data_index_] = tmp_temp_mon_stm32f103_uart1_serial_receive_uint8_t_interrupt_data;
        temp_mon_stm32f103_uart1_receive_data_index_++;
    }
}
```

### 反例

c++

```
// 10.1 循环索引反例
for (int i = 0; i < len; i++) { ... } // 极简i/len，无任何语义与标识
for (int frame_idx = 0; frame_idx < 4; frame_idx++) { // 无项目+芯片标识

// 10.2 类型转换反例
uint32_t tmp_float_to_u32 = (uint32_t)val; // 类型缩写+极简val，无标识
float tmp_u16_to_float = (float)raw / 4095.0f * 3.3f; // 极简raw，无语义

// 10.3 指令加载反例
uint32_t tmp_reg_load = *GPIOA_MODER; // 无项目+芯片标识，极简
uint8_t tmp_flash_load = FlashRead(0x08008000); // 无数据类型+用途标识

// 10.4 寄存器位操作反例
uint32_t tmp_bit_mode = (GPIOA->MODER & GPIO_MODER_MODE5) >> 10; // 无硬件+寄存器标识
uint32_t tmp_bit_irq = USART1->CR1 | USART1_CR1_RXNEIE; // 无功能+操作类型标识

// 10.5 通用临时变量反例
uint8_t tmp_check = 0; // 语义不完整，无sum/calculate标识
uint32_t tmp_tick = HAL_GetTick(); // 无项目+芯片+单位标识
uint8_t tmp_buf[16]; // 极简buf，无所属功能+数据类型标识

// 10.6 中断临时变量反例
void USART1_IRQHandler(void) {
    uint8_t a = USART1->DR; // 单字母极简，无任何语义与标识
    uint32_t b = USART1->SR; // 单字母极简，无任何语义与标识
}
```

## 11. 嵌入式硬件专属命名规则（强制全标识）

### 总述

嵌入式开发中**所有与硬件直接关联**的命名（文件 / 类型 / 变量 / 函数 / 常量 / 宏 / 枚举 / 临时变量），必须遵循上述通用规则，并**强制添加完整硬件标识**，标识为**项目名 + 芯片型号 + 外设缩写 + 外设编号 + 引脚 / 通道编号**，无任何省略；硬件操作相关命名需与**芯片官方手册**的寄存器定义、外设功能、参数术语严格同步，禁止自定义极简标识与术语。

### 核心强制要求

1. **硬件标识唯一性**：所有硬件命名的标识需保证**项目内唯一**，禁止跨外设 / 跨芯片使用相同标识，避免命名冲突。
2. **标识顺序固定**：硬件标识顺序强制为`项目名 → 芯片型号 → 外设缩写 → 外设编号 → 引脚/通道编号`，项目内所有硬件命名保持一致，禁止随意调整。
3. **术语手册同步**：硬件功能描述、寄存器名、位标识、参数名等，必须与芯片**数据手册 / 参考手册 / 标准库**术语完全一致，禁止自定义缩写与术语。
4. **无硬件极简操作**：硬件操作（读 / 写 / 设置 / 清除 / 采集 / 传输）的命名需使用**完整动作词汇**（如`Read`/`Write`/`Set`/`Clear`/`Collect`/`Transmit`），禁止极简动作词（如`Rd`/`Wr`/`SetVal`）。

### 嵌入式硬件命名通用格式（强制）

|命名对象|强制命名格式（嵌入式硬件）|格式说明|
|---|---|---|
|硬件文件|项目名_芯片型号_外设缩写_编号_功能类型_driver/module/config.(h/cc)|功能类型为强制项|
|硬件类型|项目名芯片型号外设缩写编号功能 + 语义后缀（Config/Driver/Enum/Properties）|大驼峰，语义后缀强制|
|硬件变量|项目名_芯片型号_外设缩写_编号_功能_数据类型_状态 / 单位 / 值|小写下划线，类成员加_结尾|
|硬件常量|k + 项目名芯片型号外设缩写编号功能值含义 + 单位|k 开头 + 大驼峰，单位强制|
|硬件函数|项目名芯片型号外设缩写编号 + 动作 + 功能 + 具体操作|大驼峰，动作词完整|
|硬件宏|项目名_芯片型号_外设缩写_编号_硬件类型_功能_地址 / 引脚 / 位标识|全大写 + 下划线，CFG_前缀强制|
|硬件枚举|项目名芯片型号外设缩写编号功能 + 类型 + Enum（类型名）/k + 核心语义 + 具体状态（值）|类型大驼峰，值 k 开头大驼峰|
|硬件临时变量|tmp_项目名_芯片型号_外设缩写_编号_功能_数据类型_操作_用途|tmp_前缀，小写下划线|

## 12. 命名规则特例与优先级

### 12.1 命名规则特例

**仅允许一种特例**：与**C/C++ 标准库 / 行业权威硬件库**（如 ST HAL/LL 库、NXP MCUXpresso 库、TI Driverlib 库）深度交互时，可参考库的命名策略，但**必须在库命名基础上补充项目 + 芯片完整标识**，禁止直接使用库的极简命名，无其他任何特例。

#### 特例示例（补充标识，无纯极简）

c++

```
// 参考标准库open()，补充项目+芯片+功能标识
temp_mon_stm32f103_file_system_open();
// 参考ST HAL库GPIO_Init()，补充项目+芯片+引脚完整标识
TempMonStm32f103Gpioa5PinInitConfig();
// 参考标准库uint32_t，补充项目+语义标识
typedef uint32_t TempMonStm32f103SystemDataUint32t;
```

### 12.2 命名规则优先级

当不同场景的命名规则存在冲突时，按以下优先级执行，**嵌入式硬件特性与无极简要求为最高优先级**，无例外：

1. **全域无极简优先**：所有命名的第一要求为**完整语义化 + 专属标识化**，禁止任何形式的极简 / 缩写 / 无意义标识，此规则优先于所有其他规则。
2. **硬件语义完整优先**：嵌入式硬件相关命名，必须保证**硬件标识完整 + 与芯片手册术语同步**，优先于通用命名的格式细节。
3. **可读性优先**：在语义完整、标识完整的前提下，保证命名的可读性，避免过度嵌套 / 过长字符（控制在 5-30 字符），无需为了 “格式严格” 牺牲可读性。
4. **团队一致性优先**：项目 / 团队内统一命名风格（如缩写 / 语义后缀 / 硬件标识顺序），所有成员严格遵循，禁止个人随意修改。
5. **生态兼容优先**：与标准库 / 第三方库交互的代码，在补充完整标识的前提下，参考库的命名风格，保证生态兼容。

## 13. 团队落地强制约定

1. 本手册为嵌入式 C/C++ 开发**强制命名规范**，取消所有极简命名特例，团队所有成员严格遵循，无任何例外情况。
2. 项目启动前需制定 **《项目专属命名补充文档》**，明确：项目名完整标识、芯片型号完整缩写、外设功能术语与芯片手册的对应关系、项目内统一的语义后缀，文档随项目同步维护。
3. 禁止在项目开发过程中新增**任何极简缩写 / 自定义术语**，若需新增行业缩写，需在《项目专属命名补充文档》中备案并完成团队同步，禁止个人随意新增。
4. 代码评审时，**极简命名为严重违规项**：包含任何无意义单字母 / 极简缩写 / 模糊标识 / 硬件标识缺失的代码，禁止合入代码仓库。
5. 项目内指定**命名规范负责人**，负责解答命名疑问、维护《项目专属命名补充文档》、监督规范执行，确保团队内命名风格 100% 一致。
6. 新成员加入项目时，需先学习本手册与《项目专属命名补充文档》，并通过命名规范考核，方可参与代码开发。

## 14. 嵌入式通用外设缩写表（强制统一）

本缩写表为**行业通用完整缩写**，禁止极简 / 自定义缩写，嵌入式硬件命名中需直接使用，无其他缩写形式；未列出的外设，按芯片手册**完整英文术语**命名，禁止自行缩写。

|外设 / 硬件模块|强制统一缩写|外设 / 硬件模块|强制统一缩写|外设 / 硬件模块|强制统一缩写|
|---|---|---|---|---|---|
|UART/USART（串口）|uart|I2C（集成电路总线）|i2c|SPI（串行外设接口）|spi|
|CAN（控制器局域网）|can|ADC（模数转换器）|adc|DAC（数模转换器）|dac|
|TIM/TIMER（定时器）|tim|GPIO（通用输入输出）|gpio|DMA（直接内存访问）|dma|
|Flash（闪存）|flash|RAM（随机存储器）|ram|RTC（实时时钟）|rtc|
|WDT（看门狗）|wdt|PWM（脉冲宽度调制）|pwm|IWDG（独立看门狗）|iwdg|
|I2S（音频串行总线）|i2s|SDIO（SD 卡接口）|sdio|ETH（以太网）|eth|
|USB（通用串行总线）|usb|SPI_FLASH（SPI 闪存）|spi_flash|EEPROM（电可擦除）|eeprom|
|PWR（电源管理）|pwr|RCC（时钟控制）|rcc|EXTI（外部中断）|exti|
|SPI_EEPROM（SPI EEPROM）|spi_eeprom|I2C_EEPROM（I2C EEPROM）|i2c_eeprom|CANFD（CANFD 总线）|canfd|
|LPUART（低功耗串口）|lpuart|LPSPI（低功耗 SPI）|lpspi|LPI2C（低功耗 I2C）|lpi2c|